## 同期処理

### レースコンディション
- 日本語で競合状態と訳す。複数のプロセスが並行して共有リソースにアクセスした結果引き起こされる予期せぬ出来事（バグ）
- レースコンディションをいかに引き起こさずプログラミングできるかが課題である

### アトミック処理
- 分割不可能な処理
- アトミック処理を途中状態はシステムが観測していない。その処理が失敗したら処理前の上地帯に復元される

### Compare and Swap
同期処理機構の1つ

C言語では組み込み関数の`__sync_bool_compare_and_swap`がある。
- C言語ではゼロがfalse、非ゼロがtrueの意味になる

### Test and Set
- CASと同じ用に組み込み関数が存在する
- 入力されたポインpの指す値がtrueなら単純にreturnする.
- falseなら、pのメモリをtrueにしてfalseをreturn

## ミューテックス
- 日本語だと排他実行とも言う
- 以下のようなイメージ

useEffectのマウント状態かどうかを確認するフラグのようなもの？

```c

bool lock = false; // 共有なフラグ変数

void some_func() {
  retry:
  if (!lock) {
    lock = true;
    // クリティカルセクション
  } else {
    goto retry;
  }
  lock = false; // ロック解放
}

```

- しかし上記の場合でもレースコンディションが起きるのでTAS関数を利用してlockの値を検査すると排他制御する


### スピンロック
先程のロックが獲得できるまでのループを繰り返してリソースの空きをポーリングして確認する方法をスピンロックという

- スピンロックではロックを獲得するまでループして何度も共有変数を確認するためクリティカルセクション中の処理量が多くオーバヘッドになる
- クリティカルセクション中にOSのスケジューラによってOSぷろせすが割り込みによって待機状態になるとペナルティが大きくなることからスピンロック単体利用は推奨していない
- 代わりにミューテックスかライブラリを組み合わせて利用するべき

```c

bool lock = false;

void some_func() {
  for (;;) {
    spinlock_aqcuire($lock) // ロック獲得
    spinlock_release($lock) // ロック解放
  }
}

```

### Pthreadsのミューテックス

通常はPthreadsなどで実行することが推奨される

### セマフォ
- ミューテックスはロックを獲得できるprocessが最大1つだった.
- セマフォでは最大Nプロセスまで同時にロックを獲得できる
- 航空機などの利用は椅子の数に限りがあるため利用者を制限を設ける→これがセマフォ


### バリア同期
- 小学校の遠足は色々な場所に集団で移動するが、移動は必ずクラスの前任が揃ってかを確認してから行われる。
- 全員揃ってから実行する処理をバリア同期という

スピンロックベースのバリア同期
- 共有変数を良いうい
- プロセスがある地点にたどり着いたら共有変数をインクリメントする
- 共有変数がインクリメントされ続けてある一定の数まで達したらバリアを抜けて処理を続行する

```c

void barrier(volatile int *cnt, int max) {
  __sync_fetch_add_add(cnt, 1);
  while(*cnt < max);
}

```

- レースコンディションが発生する原因は書き込みを行うからである

### Rustの同期処理ライブラリ

同期処理のライブラリは言語の標準ライブラリになって提供されている

ミューテックス（コード書いている（mtx.rs））

- Rustでは、Mutex用の変数は保護対象のデータを保持するようなっている
- ロックしなければ保護対象データにアクセスできないようになっている
- C言語だと保護対象のデータはろっくしなくてもアクセスできてしまっていた
- Rustはコンパイル時に共有リソースへの不正なアクセスを防ぐことができるように設計されている
- そのためPthreadsで起きていたロックの獲得と解放忘れを防ぐことができる